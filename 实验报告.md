# <center>LAB4 实验报告</center>

## 任务一

​		先来看boot_map_region函数：

~~~c
static void boot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm){
	// Fill this function in
	size_t pgs = size / PGSIZE;
	if (size % PGSIZE != 0)
		pgs++;//如果size不是PGSIZE的倍数，将其填充为PGSIZE的倍数。
	for (int i = 0; i < pgs; i++){
        //利用pgdir_walk函数返回地址va所对应的页表项指针。
		pte_t *pte = pgdir_walk(pgdir, (void *)va, 1);
		if (pte == NULL)
			panic("boot_map_region(): out of memory\n");
		*pte = pa | PTE_P | perm;//将页表项对应到相应的物理地址。
		pa += PGSIZE;
		va += PGSIZE;
	}
}
~~~

​		该函数的作用为将[va,va+size)的虚拟地址空间映射到[pa,pa+size)的物理地址空间，并将该映射关系保存到页表中。

​		再看mmio_map_region函数：

~~~c
void* mmio_map_region(physaddr_t pa, size_t size){
	static uintptr_t base = MMIOBASE;
	size = ROUNDUP(pa + size, PGSIZE);//让空间大小为PGSIZE的倍数。
	pa = ROUNDDOWN(pa, PGSIZE);//让起始地址和物理页对齐。
	size -= pa;
	if (base + size >= MMIOLIM)//超过了mmio的内存限制
		panic("not enough memory");
	boot_map_region(kern_pgdir, base, size, pa, PTE_PCD | PTE_PWT | PTE_W);
	base += size;//更新base
	return (void *)(base - size);//返回分配的mmio空间的起始地址
}
~~~

​		而mmio_map_region函数就是利用boot_map_region函数，将地址[base,base+size)映射到物理地址[pa，pa+size)，其中base一开始是MMIOBASE，即MMIO的起始地址。每调用一次mmio_map_region函数，base都会往后移size大小，使base始终为mmio中未被分配的内存的起始地址。

## 任务二

​		MPBOOTPHYS宏定义如下：

~~~c
#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR)
~~~

​		作为为利用地址s计算处基于MPENTRY_PADDR的绝对地址。

​		boot_aps函数中将mpentry.S中的代码链接到在KERNBASE（0xF000000）之上的虚拟地址处，而代码实际装载在MPENTRY_PADDR（0x7000）处，而实模式下只支持1MB的物理寻址，因此如果mpentry.S不采用MPBOOTPHYS寻址的话就会出现寻址错误。而boot.S的链接地址和加载地址均在低地址，可以采用实模式寻址，不需要用MPBOOTPHYS寻址。

## 任务三

​		在i386_init函数调用了lapic_init函数初始化最开始用来引导的bootcpu的TSS 和 IDT。然后调用boot_aps函数初始化其他cpu。

~~~c
	// Lab 4 multiprocessor initialization functions
	mp_init();	
	lapic_init();	

	// Lab 4 multitasking initialization functions
	pic_init();

	// Acquire the big kernel lock before waking up APs
	// Your code here:
	lock_kernel();	
	// Starting non-boot CPUs
	boot_aps();		

~~~

​		在boot_aps函数中，对每个cpu会调用lapic_startap函数来执行mpentry.S中的指令。

~~~c
	for (c = cpus; c < cpus + ncpu; c++) {
		if (c == cpus + cpunum())  // We've started already.
			continue;

		// Tell mpentry.S what stack to use 
		mpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;
		// Start the CPU at mpentry_start
		lapic_startap(c->cpu_id, PADDR(code));
		// Wait for the CPU to finish some basic setup in mp_main()
		while(c->cpu_status != CPU_STARTED)
			;
	}
~~~

​		在mpentry.S，发现调用了mp_main函数：

~~~assembly
	# Call mp_main().  (Exercise for the reader: why the indirect call?)
	movl    $mp_main, %eax
	call    *%eax
~~~

​		在mp_main函数会调用trap_init_percpu函数：

~~~c
	lapic_init();
	env_init_percpu();
	trap_init_percpu();
	xchg(&thiscpu->cpu_status, CPU_STARTED); // tell boot_aps() we're up
~~~

​		这样就完成了对每个non-boot cpu（AP）的TSS 和 IDT的初始化。

## 任务四

### question2

​		每个cpu运行时在栈上的信息很有可能不同，而有的程序在获得锁之前就对内核栈进行了修改，例如系统是在将相关数据压入栈后才调用的trap函数，然后在trap函数中获得锁。而在获得锁之前其他cpu可以修改内核栈，这样就会修改原本的信息，因此不能使用共享栈。

### spin_lock

~~~c
void spin_lock(struct spinlock *lk){
#ifdef DEBUG_SPINLOCK
	if (holding(lk))
		panic("CPU %d cannot acquire %s: already holding", cpunum(), lk->name);
#endif
	// The xchg is atomic.
	// It also serializes, so that reads after acquire are not reordered before it.
	while (xchg(&lk->locked, 1) != 0)
		asm volatile ("pause");	
	// Record info about lock acquisition for debugging.
#ifdef DEBUG_SPINLOCK
	lk->cpu = thiscpu;
	get_caller_pcs(lk->pcs);
#endif
}
~~~

​		可以看到，代码先检查当前cpu是否已经获得了锁，如果已经获得了锁，就抛出异常。如果还没有获得锁，就进入while循环，直到检测到当前cpu获得了锁后退出循环。然后将当前cpu的信息和堆栈保存下来。

### spin_unlock

~~~c
void spin_unlock(struct spinlock *lk){
#ifdef DEBUG_SPINLOCK
	if (!holding(lk)) {
		int i;
		uint32_t pcs[10];
		// Nab the acquiring EIP chain before it gets released
		memmove(pcs, lk->pcs, sizeof pcs);
		cprintf("CPU %d cannot release %s: held by CPU %d\nAcquired at:", 
			cpunum(), lk->name, lk->cpu->cpu_id);
		for (i = 0; i < 10 && pcs[i]; i++) {
			struct Eipdebuginfo info;
			if (debuginfo_eip(pcs[i], &info) >= 0)
				cprintf("  %08x %s:%d: %.*s+%x\n", pcs[i],
					info.eip_file, info.eip_line,
					info.eip_fn_namelen, info.eip_fn_name,
					pcs[i] - info.eip_fn_addr);
			else
				cprintf("  %08x\n", pcs[i]);
		}
		panic("spin_unlock");
	}
	lk->pcs[0] = 0;
	lk->cpu = 0;
#endif
	xchg(&lk->locked, 0);
}
~~~

​		代码先检查当前cpu是否获得了锁，如果当前cpu并没有获得锁，输出cpu相应信息并抛出异常。如果当前cpu持有锁，将锁中保存的cpu信息清零，然后释放锁。

### xchg

~~~c
xchg(volatile uint32_t *addr, uint32_t newval){
	uint32_t result;
	// The + in "+m" denotes a read-modify-write operand.
	asm volatile("lock; xchgl %0, %1"
		     : "+m" (*addr), "=a" (result)
		     : "1" (newval)
		     : "cc");
	return result;
}
~~~

​		该函数实现锁结构的locked信号量的更新，持有锁为1，没有锁为0。“lock”标签使得信号量的更新原子化，且让系统不能跨locked信号量更新操作对指令进行重排序，使得该在cpu没有锁时进行的操作只能在没有锁时进行；在cpu获得锁时进行的操作只能在cpu获得锁后进行。

## 任务五

### question3

~~~c
	if (curenv != NULL && curenv->env_status == ENV_RUNNING) {	
		curenv->env_status = ENV_RUNNABLE;
	}
	curenv = e;
	e->env_status = ENV_RUNNING;
	e->env_runs++;
	lcr3(PADDR(e->env_pgdir));
	unlock_kernel();						
	env_pop_tf(&e->env_tf);
~~~

​		代码中lcr3只是修改了进程页表，而envs数组是内核数据，e指针的虚拟地址和实际物理地址都没有改变，因此可以继续使用指针e取值。

### question4

​		保存寄存器是因为很有可能在新环境中旧环境会改变原本寄存器中的值，如果不保存就无法保证指令正常、正确执行。

​		在trapentry.S中的_alltraps中会保存当前环境的寄存器：

~~~assembly
_alltraps:
    pushl %ds
    pushl %es
    pushal
    movw $GD_KD, %ax
    movw %ax, %ds
    movw %ax, %es
    pushl %esp
    call trap
~~~

​		然后再env_run函数最后会用env_pop_tf函数将寄存器恢复到中断前的状态。	
